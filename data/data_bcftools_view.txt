[
    {"query": "drop all genotypes", "response": "bcftools view -G your_vcf.vcf"},
    {"query": "output only VCF header", "response": "bcftools view -h your_vcf.vcf"},
    {"query": "suppress VCF header in output", "response": "bcftools view -H your_vcf.vcf"},
    {"query": "output VCF header and records", "response": "bcftools view --with-header your_vcf.vcf"},
    {"query": "set compression level to maximum", "response": "bcftools view -l 9 your_vcf.vcf"},
    {"query": "convert VCF to uncompressed BCF", "response": "bcftools view -O u your_vcf.vcf"},
    {"query": "output to a specific file", "response": "bcftools view -o output_file.vcf your_vcf.vcf"},
    {"query": "filter by region", "response": "bcftools view -r chr1:1000-5000 your_vcf.vcf"},
    {"query": "filter by multiple regions from file", "response": "bcftools view -R regions_file.txt your_vcf.vcf"},
    {"query": "trim alternate alleles not in genotypes", "response": "bcftools view -a your_vcf.vcf"},
    {"query": "do not update INFO fields for subset", "response": "bcftools view -I your_vcf.vcf"},
    {"query": "subset by specific samples", "response": "bcftools view -s sample1,sample2 your_vcf.vcf"},
    {"query": "subset by samples from file", "response": "bcftools view -S samples_file.txt your_vcf.vcf"},
    {"query": "exclude sites with expression", "response": "bcftools view -e 'DP<10' your_vcf.vcf"},
    {"query": "include only homozygous sites", "response": "bcftools view -g hom your_vcf.vcf"},
    {"query": "include sites with minimum allele count 5", "response": "bcftools view -c 5 your_vcf.vcf"},
    {"query": "exclude sites with maximum allele frequency 0.1", "response": "bcftools view -Q 0.1 your_vcf.vcf"},
    {"query": "print only known sites", "response": "bcftools view -k your_vcf.vcf"},
    {"query": "print sites with at least 3 alleles", "response": "bcftools view -m 3 your_vcf.vcf"},
    {"query": "print novel sites only", "response": "bcftools view -n your_vcf.vcf"},
    {"query": "exclude sites with all phased samples", "response": "bcftools view -P your_vcf.vcf"},
    {"query": "print sites with minimum allele frequency 0.05", "response": "bcftools view -q 0.05 your_vcf.vcf"},
    {"query": "include sites without a called genotype", "response": "bcftools view -u your_vcf.vcf"},
    {"query": "select only SNP variants", "response": "bcftools view -v snps your_vcf.vcf"},
    {"query": "exclude indel variants", "response": "bcftools view -V indels your_vcf.vcf"},
    {"query": "drop genotypes and output only VCF header", "response": "bcftools view -G -h your_vcf.vcf"},
    {"query": "output VCF header and records with maximum compression", "response": "bcftools view --with-header -l 9 your_vcf.vcf"},
    {"query": "convert VCF to uncompressed BCF and exclude header", "response": "bcftools view -O u -H your_vcf.vcf"},
    {"query": "filter by region and suppress header", "response": "bcftools view -r chr1:1000-5000 -H your_vcf.vcf"},
    {"query": "trim alt alleles and exclude sites with low depth", "response": "bcftools view -a -e 'DP<10' your_vcf.vcf"},
    {"query": "subset by samples and output to specific file", "response": "bcftools view -s sample1,sample2 -o subset.vcf your_vcf.vcf"},
    {"query": "filter by region file and set compression level", "response": "bcftools view -R regions_file.txt -l 5 your_vcf.vcf"},
    {"query": "exclude phased sites and known sites", "response": "bcftools view -P -k your_vcf.vcf"},
    {"query": "include sites with min allele frequency and exclude header", "response": "bcftools view -q 0.05 -H your_vcf.vcf"},
    {"query": "print only SNPs with min allele count 10", "response": "bcftools view -v snps -c 10 your_vcf.vcf"},
    {"query": "exclude indels and novel sites", "response": "bcftools view -V indels -n your_vcf.vcf"},
    {"query": "output to file with max compression", "response": "bcftools view -o output.vcf -l 9 your_vcf.vcf"},
    {"query": "include only homozygous sites with specific region", "response": "bcftools view -g hom -r chr1 your_vcf.vcf"},
    {"query": "print sites with at least 2 alleles and exclude private", "response": "bcftools view -m 2 -X your_vcf.vcf"},
    {"query": "exclude sites with expression and max allele count", "response": "bcftools view -e 'DP<10' -C 5 your_vcf.vcf"},
    {"query": "drop genotypes and subset by specific samples file", "response": "bcftools view -G -S samples_file.txt your_vcf.vcf"},
    {"query": "filter by multiple regions and suppress header", "response": "bcftools view -r chr1:1000-5000,chr2:2000-3000 -H your_vcf.vcf"},
    {"query": "include sites with max allele frequency and known sites", "response": "bcftools view -Q 0.1 -k your_vcf.vcf"},
    {"query": "output both header and records, exclude uncalled sites", "response": "bcftools view --with-header -U your_vcf.vcf"},
    {"query": "print novel sites and set uncompressed output", "response": "bcftools view -n -O u your_vcf.vcf"},
    {"query": "exclude sites with max allele frequency and include header", "response": "bcftools view -Q 0.2 --with-header your_vcf.vcf"},
    {"query": "output to file and exclude sites without a called genotype", "response": "bcftools view -o output.vcf -U your_vcf.vcf"},
    {"query": "trim alt alleles not in subset samples and filter by region", "response": "bcftools view -a -r chr1:1000-5000 your_vcf.vcf"},
    {"query": "filter by region file and print only biallelic SNPs", "response": "bcftools view -R regions_file.txt -v snps -m2 -M2 your_vcf.vcf"},
    {"query": "exclude indels and exclude sites with expression", "response": "bcftools view -V indels -e 'QUAL<20' your_vcf.vcf"},
  {"query": "Annotate a VCF file with a new header", "response": "bcftools annotate input.vcf -h new_header.txt -o annotated.vcf"},
  {"query": "Add annotations from a tab-delimited file", "response": "bcftools annotate input.vcf -a annotations.txt -c CHROM,POS,ID -o annotated.vcf"},
  {"query": "Annotate using INFO fields from another VCF", "response": "bcftools annotate input.vcf -a info.vcf -c INFO/DP,INFO/AF -o annotated.vcf"},
  {"query": "Remove specific INFO fields from a VCF file", "response": "bcftools annotate input.vcf -x INFO/DP,INFO/AF -o cleaned.vcf"},
  {"query": "Annotate and compress the output in BCF format", "response": "bcftools annotate input.vcf -a annotations.vcf -O b -o annotated.bcf"},
  {"query": "Annotate a VCF file and convert it to BCF", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -O b -o annotated.bcf"},
  {"query": "Replace annotations in a VCF file", "response": "bcftools annotate input.vcf -a replace_annotations.vcf -o replaced.vcf"},
  {"query": "Annotate and filter variants simultaneously", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools filter -i 'DP>10' -o filtered_annotated.vcf"},
  {"query": "Annotate with a custom expression", "response": "bcftools annotate input.vcf -e 'AF<0.05' -a annotations.vcf -o low_af_annotated.vcf"},
  {"query": "Annotate with regions from a BED file", "response": "bcftools annotate input.vcf -a regions.bed -R regions.bed -o region_annotated.vcf"},
  {"query": "Annotate and index the output VCF", "response": "bcftools annotate input.vcf -a annotations.vcf -o annotated.vcf --output-type z --threads 2"},
  {"query": "Combine annotate and stats responses", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools stats -s - -o stats.txt"},
  {"query": "Annotate and normalize indels", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools norm -f reference.fa -o normalized.vcf"},
  {"query": "Annotate and merge with another VCF", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools merge input2.vcf -o merged.vcf"},
  {"query": "Annotate and convert to tab-delimited format", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\n' -o output.txt"},
  {"query": "Annotate with multiple annotation files", "response": "bcftools annotate input.vcf -a annotations1.vcf,annotations2.vcf -o multi_annotated.vcf"},
  {"query": "Annotate and exclude specific samples", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -s sample1,sample2 -O v -o sample_excluded.vcf"},
  {"query": "Annotate and subset to specific regions", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -T regions.bed -o region_subset.vcf"},
  {"query": "Annotate with gene names from a GFF file", "response": "bcftools annotate input.vcf -a genes.gff -c CHROM,FROM,TO,GENE -g gene_map.txt -o gene_annotated.vcf"},
  {"query": "Annotate and calculate allele frequencies", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools +fill-tags -o annotated_with_af.vcf"},
  {"query": "Annotate and convert to uncompressed BCF", "response": "bcftools annotate input.vcf -a annotations.vcf -O u -o uncompressed.bcf"},
  {"query": "Annotate and extract specific samples", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -s sample1,sample2 -o extracted_samples.vcf"},
  {"query": "Annotate, compress and index output", "response": "bcftools annotate input.vcf -a annotations.vcf -O z -o annotated.vcf.gz --threads 4"},
  {"query": "Annotate and recalculate AC and AN", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools +fill-tags -t AC,AN -o recalculated.vcf"},
  {"query": "Annotate and remove private alleles", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -x -o private_removed.vcf"},
  {"query": "Annotate with allele frequencies from another VCF", "response": "bcftools annotate input.vcf -a freq.vcf -c CHROM,POS,AF -o af_annotated.vcf"},
  {"query": "Annotate VCF and exclude variants based on expression", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -e 'QUAL<20' -o high_qual.vcf"},
  {"query": "Annotate and sort the VCF file", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools sort -o sorted.vcf"},
  {"query": "Annotate and convert to JSON format", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -O j -o annotated.json"},
  {"query": "Annotate and perform variant calling", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools call -mv -o called.vcf"},
  {"query": "Annotate with custom tags and output to uncompressed VCF", "response": "bcftools annotate input.vcf -a custom_tags.txt -c TAG1,TAG2 -O v -o custom_tagged.vcf"},
  {"query": "Annotate and split multi-allelic records", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools norm -m -any -o split.vcf"},
  {"query": "Annotate, compress, and output as tab-delimited text", "response": "bcftools annotate input.vcf -a annotations.vcf -O z | bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\n' -o output.tsv.gz"},
  {"query": "Annotate and concatenate with another VCF file", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools concat input2.vcf -o concatenated.vcf"},
  {"query": "Annotate with a BED file and filter by regions", "response": "bcftools annotate input.vcf -a regions.bed -R regions.bed | bcftools view -R regions.bed -o region_filtered.vcf"},
  {"query": "Annotate and select specific types of variants", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -v snps -o snps_only.vcf"},
  {"query": "Annotate and merge multiple VCFs into one", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools merge input2.vcf input3.vcf -o merged.vcf"},
  {"query": "Annotate and convert to uncompressed JSON format", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -O j -o uncompressed.json"},
  {"query": "Annotate and apply complex filtering expressions", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools filter -e 'DP<10 && QUAL<20' -o filtered.vcf"},
  {"query": "Annotate and split VCF by chromosomes", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools +split -o split_by_chrom"},
  {"query": "Annotate and calculate Hardy-Weinberg equilibrium", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools +fill-tags -- -t HWE -o annotated_with_hwe.vcf"},
  {"query": "Annotate and create a consensus sequence", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools consensus -f reference.fa -o consensus.fa"},
  {"query": "Annotate and convert to CSV format", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools query -f '%CHROM,%POS,%REF,%ALT\n' -o annotated.csv"},
  {"query": "Annotate and output VCF file with specific columns", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools query -f '%CHROM\t%POS\t%ID\t%REF\t%ALT\t%QUAL\t%FILTER\n' -o custom_columns.vcf"},
  {"query": "Annotate and extract regions to a new file", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools isec -p dir -n=2 -w1"},
  {"query": "Annotate and remove duplicates", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools norm -d all -o deduplicated.vcf"},
  {"query": "Annotate and replace sample names", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools reheader -s sample_names.txt -o renamed_samples.vcf"},
  {"query": "Annotate and select only variants with PASS in FILTER", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -f PASS -o pass_only.vcf"},
  {"query": "Annotate and remove sites failing quality checks", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -T ^failed_sites.bed -o qc_passed.vcf"},
  {"query": "Annotate and output to a specific region in BED format", "response": "bcftools annotate input.vcf -a annotations.vcf | bcftools view -T regions.bed -O b -o region_specific.bcf"},
  {"query": "Call variants with a specific calling method", "response": "bcftools call input.vcf -mv -O v -o called_output.vcf"},
  {"query": "Concatenate multiple VCF files and reheader", "response": "bcftools concat file1.vcf file2.vcf -O z -o concatenated.vcf.gz --reheader new_header.txt"},
  {"query": "Call variants and output in uncompressed BCF format", "response": "bcftools call input.vcf -mv -O u -o called_output.bcf"},
  {"query": "Concatenate VCF files and exclude specific regions", "response": "bcftools concat file1.vcf file2.vcf -R exclude_regions.bed -O v -o concatenated.vcf"},
  {"query": "Call consensus sequence from variant calling", "response": "bcftools call input.vcf -c -o consensus_call.vcf"},
  {"query": "Call variants and filter for specific regions", "response": "bcftools call input.vcf -mv | bcftools view -R regions.bed -o region_specific_calls.vcf"},
  {"query": "Concatenate multiple VCFs and output as BCF", "response": "bcftools concat file1.vcf file2.vcf -O b -o concatenated_output.bcf"},
  {"query": "Call variants and annotate results", "response": "bcftools call input.vcf -mv | bcftools annotate -a annotations.vcf -o annotated_calls.vcf"},
  {"query": "Concatenate and normalize VCF files", "response": "bcftools concat file1.vcf file2.vcf | bcftools norm -m -any -o normalized_concatenated.vcf"},
  {"query": "Call variants with ploidy assumption", "response": "bcftools call input.vcf -mv -ploidy 2 -o ploidy_call.vcf"},
  {"query": "Concatenate VCFs and convert to tab-delimited format", "response": "bcftools concat file1.vcf file2.vcf | bcftools query -f '%CHROM\\t%POS\\t%REF\\t%ALT\\n' -o concatenated.tsv"},
  {"query": "Call variants and generate statistics", "response": "bcftools call input.vcf -mv | bcftools stats -s - -o stats.txt"},
  {"query": "Concatenate and filter variants simultaneously", "response": "bcftools concat file1.vcf file2.vcf | bcftools view -i 'DP>10' -o filtered_concatenated.vcf"},
  {"query": "Call variants and exclude sites based on expression", "response": "bcftools call input.vcf -mv | bcftools view -e 'QUAL<20' -o high_qual_calls.vcf"},
  {"query": "Concatenate and output only SNPs", "response": "bcftools concat file1.vcf file2.vcf | bcftools view -v snps -o snps_concatenated.vcf"},
  {"query": "Call variants and output as uncompressed JSON", "response": "bcftools call input.vcf -mv | bcftools view -O j -o called.json"},
  {"query": "Concatenate VCFs and remove duplicates", "response": "bcftools concat file1.vcf file2.vcf | bcftools norm -d all -o deduplicated_concatenated.vcf"},
  {"query": "Call variants and calculate allele frequencies", "response": "bcftools call input.vcf -mv | bcftools +fill-tags -- -t AF -o called_with_af.vcf"},
  {"query": "Concatenate VCF files and extract specific regions", "response": "bcftools concat file1.vcf file2.vcf -R regions.bed -O v -o region_extracted.vcf"},
  {"query": "Call variants and select only variants with PASS in FILTER", "response": "bcftools call input.vcf -mv | bcftools view -f PASS -o pass_only_calls.vcf"},
  {"query": "Concatenate and apply complex filtering expressions", "response": "bcftools concat file1.vcf file2.vcf | bcftools filter -e 'DP<10 && QUAL<20' -o filtered_concatenated.vcf"},
  {"query": "Call variants and convert to CSV format", "response": "bcftools call input.vcf -mv | bcftools query -f '%CHROM,%POS,%REF,%ALT\\n' -o called.csv"},
  {"query": "Concatenate VCFs and recalculate AC and AN", "response": "bcftools concat file1.vcf file2.vcf | bcftools +fill-tags -t AC,AN -o recalculated_concatenated.vcf"},
  {"query": "Call variants and subset to specific samples", "response": "bcftools call input.vcf -mv | bcftools view -s sample1,sample2 -o sample_specific_calls.vcf"},
  {"query": "Concatenate, compress, and index output VCF files", "response": "bcftools concat file1.vcf file2.vcf -O z -o concatenated.vcf.gz --threads 4"},
  {"query": "Detect CNVs using default settings", "response": "bcftools cnv input.vcf -o cnv_output.txt"},
  {"query": "Detect CNVs with a specific window size", "response": "bcftools cnv input.vcf -w 500 -o cnv_window_output.txt"},
  {"query": "Detect CNVs and filter based on quality", "response": "bcftools cnv input.vcf | bcftools view -i 'QUAL>20' -o high_qual_cnv_output.vcf"},
  {"query": "Detect CNVs and output in BED format", "response": "bcftools cnv input.vcf -O b -o cnv_output.bed"},
  {"query": "Detect CNVs and annotate with gene names", "response": "bcftools cnv input.vcf | bcftools annotate -a genes.gff -c CHROM,FROM,TO,GENE -o annotated_cnv_output.txt"},
  {"query": "Detect CNVs with specific method and output as JSON", "response": "bcftools cnv input.vcf -m HMM | bcftools view -O j -o cnv_output.json"},
  {"query": "Detect CNVs and concatenate with another CNV file", "response": "bcftools cnv input.vcf | bcftools concat cnv_file2.vcf -o concatenated_cnv_output.vcf"},
  {"query": "Detect CNVs and calculate statistics", "response": "bcftools cnv input.vcf | bcftools stats -s - -o cnv_stats.txt"},
  {"query": "Detect CNVs and extract specific regions", "response": "bcftools cnv input.vcf | bcftools view -R regions.bed -o region_specific_cnv_output.vcf"},
  {"query": "Detect CNVs and select only large variants", "response": "bcftools cnv input.vcf | bcftools view -i 'LEN>1000' -o large_cnv_output.vcf"},
  {"query": "Detect CNVs and exclude specific samples", "response": "bcftools cnv input.vcf | bcftools view -s sample1,sample2 -O v -o sample_excluded_cnv_output.vcf"},
  {"query": "Detect CNVs and merge with another VCF file", "response": "bcftools cnv input.vcf | bcftools merge input2.vcf -o merged_cnv_output.vcf"},
  {"query": "Detect CNVs and output only novel sites", "response": "bcftools cnv input.vcf | bcftools view -n -o novel_cnv_output.vcf"},
  {"query": "Detect CNVs and apply complex filtering expressions", "response": "bcftools cnv input.vcf | bcftools filter -e 'DP<10 && QUAL<20' -o filtered_cnv_output.vcf"},
  {"query": "Detect CNVs and convert to uncompressed BCF format", "response": "bcftools cnv input.vcf | bcftools view -O u -o uncompressed_cnv_output.bcf"},
  {"query": "Create a consensus sequence from a VCF file", "response": "bcftools consensus -f reference.fa input.vcf -o consensus.fa"},
  {"query": "Convert a VCF file to BCF format", "response": "bcftools convert -O b input.vcf -o output.bcf"},
  {"query": "Create a consensus sequence applying specific IUPAC codes", "response": "bcftools consensus -f reference.fa -i 'IUPAC' input.vcf -o consensus_iupac.fa"},
  {"query": "Convert a BCF file to VCF format", "response": "bcftools convert -O v input.bcf -o output.vcf"},
  {"query": "Create a consensus sequence excluding specific regions", "response": "bcftools consensus -f reference.fa -r exclude.bed input.vcf -o consensus_excluded.fa"},
  {"query": "Convert a VCF file to PLINK binary format", "response": "bcftools convert --plink -o output input.vcf"},
  {"query": "Create a consensus sequence with masked regions", "response": "bcftools consensus -f reference.fa -m mask.bed input.vcf -o consensus_masked.fa"},
  {"query": "Convert VCF to PLINK PED and MAP formats", "response": "bcftools convert --vcf2plink input.vcf -o plink_output"},
  {"query": "Create a consensus sequence and annotate variants", "response": "bcftools consensus -f reference.fa input.vcf | bcftools annotate -a annotations.vcf -o annotated_consensus.fa"},
  {"query": "Convert VCF to binary PED (BED) format", "response": "bcftools convert --vcf2bed input.vcf -o bed_output"},
  {"query": "Create a consensus sequence and filter variants", "response": "bcftools consensus -f reference.fa input.vcf | bcftools view -i 'QUAL>20' -o high_qual_consensus.fa"},
  {"query": "Convert a VCF file to transposed format", "response": "bcftools convert -O t input.vcf -o transposed_output.txt"},
  {"query": "Create a consensus sequence and normalize indels", "response": "bcftools consensus -f reference.fa input.vcf | bcftools norm -m -any -o normalized_consensus.fa"},
  {"query": "Convert a VCF file to HapMap format", "response": "bcftools convert --hapmap -o hapmap_output input.vcf"},
  {"query": "Create a consensus sequence from called variants", "response": "bcftools call -mv input.vcf | bcftools consensus -f reference.fa -o called_consensus.fa"},
  {"query": "Convert a BCF file to a specific region in VCF format", "response": "bcftools convert -O v -r chr1 input.bcf -o region_output.vcf"},
  {"query": "Create a consensus sequence with a custom chain file", "response": "bcftools consensus -f reference.fa -c chain_file.txt input.vcf -o custom_chain_consensus.fa"},
  {"query": "Convert VCF to CGH format", "response": "bcftools convert --cgh -o cgh_output input.vcf"},
  {"query": "Create a consensus sequence and calculate statistics", "response": "bcftools consensus -f reference.fa input.vcf | bcftools stats -s - -o stats.txt"},
  {"query": "Convert a VCF file to SAMtools pileup format", "response": "bcftools convert -O p input.vcf -o pileup_output.txt"},
  {"query": "Create a consensus sequence and subset to specific regions", "response": "bcftools consensus -f reference.fa -T regions.bed input.vcf -o region_consensus.fa"},
  {"query": "Convert a VCF file to a compressed BCF format", "response": "bcftools convert -O b -o compressed_output.bcf input.vcf"},
  {"query": "Create a consensus sequence and output in gzip format", "response": "bcftools consensus -f reference.fa input.vcf -O z -o consensus.gz"},
  {"query": "Convert VCF to JSON format", "response": "bcftools convert -O j input.vcf -o output.json"},
  {"query": "Create a consensus sequence and annotate with gene names", "response": "bcftools consensus -f reference.fa input.vcf | bcftools annotate -a genes.gff -c CHROM,FROM,TO,GENE -o gene_annotated_consensus.fa"},
  {"query": "Predict the consequences of variants", "response": "bcftools csq -f reference.fa -g genes.gff input.vcf -o output.csq.vcf"},
  {"query": "Filter variants based on quality", "response": "bcftools filter -i 'QUAL>30' input.vcf -o high_qual.vcf"},
  {"query": "Predict consequences and filter non-coding variants", "response": "bcftools csq -f reference.fa -g genes.gff input.vcf | bcftools view -i 'TYPE!=non_coding' -o coding_only.vcf"},
  {"query": "Filter variants by depth of coverage", "response": "bcftools filter -i 'DP>10' input.vcf -o high_dp.vcf"},
  {"query": "Predict consequences and exclude specific regions", "response": "bcftools csq -f reference.fa -g genes.gff input.vcf | bcftools view -T ^regions.bed -o outside_regions.vcf"},
  {"query": "Filter variants by allele frequency", "response": "bcftools filter -i 'AF<0.01' input.vcf -o rare_variants.vcf"},
  {"query": "Predict consequences and output in BCF format", "response": "bcftools csq -f reference.fa -g genes.gff input.vcf -O b -o output.csq.bcf"},
  {"query": "Filter and annotate variants simultaneously", "response": "bcftools filter -e 'QUAL<20' input.vcf | bcftools annotate -a annotations.vcf -o annotated_filtered.vcf"},
  {"query": "Predict consequences and generate statistics", "response": "bcftools csq -f reference.fa -g genes.gff input.vcf | bcftools stats -s - -o stats.txt"},
  {"query": "Filter variants and convert to JSON format", "response": "bcftools filter -i 'QUAL>20' input.vcf | bcftools view -O j -o filtered.json"},
  {"query": "Predict consequences for specific gene regions", "response": "bcftools csq -f reference.fa -g genes.gff -r chr1:10000-20000 input.vcf -o region_specific.csq.vcf"},
  {"query": "Filter variants and create consensus sequence", "response": "bcftools filter -e 'QUAL<30' input.vcf | bcftools consensus -f reference.fa -o consensus_filtered.fa"},
  {"query": "Predict consequences with a specific transcript database", "response": "bcftools csq -f reference.fa -g genes.gff --gff-annot transcripts.gff input.vcf -o with_transcripts.csq.vcf"},
  {"query": "Filter heterozygous variants", "response": "bcftools filter -i 'GT=\"het\"' input.vcf -o heterozygous.vcf"},
  {"query": "Predict consequences and normalize variants", "response": "bcftools csq -f reference.fa -g genes.gff input.vcf | bcftools norm -m -any -o normalized.csq.vcf"},
  {"query": "Filter variants by missing genotype rate", "response": "bcftools filter -i 'F_MISSING<0.1' input.vcf -o low_missing.vcf"},
  {"query": "Predict consequences and select variants by type", "response": "bcftools csq -f reference.fa -g genes.gff input.vcf | bcftools view -v snps -o snps_only.csq.vcf"},
  {"query": "Filter variants and output as uncompressed BCF", "response": "bcftools filter -e 'DP<10' input.vcf -O u -o uncompressed.bcf"},
  {"query": "Predict consequences and exclude variants by expression", "response": "bcftools csq -f reference.fa -g genes.gff input.vcf | bcftools view -e 'AF>0.05' -o low_af_excluded.csq.vcf"},
  {"query": "Filter variants and keep only PASS records", "response": "bcftools filter -e 'FILTER!=\"PASS\"' input.vcf -o pass_only.vcf"},
  {"query": "Predict consequences and output to a specific region", "response": "bcftools csq -f reference.fa -g genes.gff -r chr2 input.vcf -o region_chr2.csq.vcf"},
  {"query": "Filter and concatenate VCF files", "response": "bcftools filter -i 'QUAL>20' input.vcf | bcftools concat input2.vcf -o concatenated.vcf"},
  {"query": "Predict consequences for variants with high impact", "response": "bcftools csq -f reference.fa -g genes.gff input.vcf | bcftools view -i 'CSQ_HIGH=1' -o high_impact.csq.vcf"},
  {"query": "Filter variants and remove duplicates", "response": "bcftools filter -i 'QUAL>20' input.vcf | bcftools norm -d all -o deduplicated.vcf"},
  {"query": "Predict consequences and output variant annotations", "response": "bcftools csq -f reference.fa -g genes.gff input.vcf | bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\t[%CSQ]\n' -o variant_annotations.txt"},
  {"query": "Check genotype concordance between two VCF files", "response": "bcftools gtcheck input1.vcf input2.vcf -o gtcheck_output.txt"},
  {"query": "Display the header of a VCF file", "response": "bcftools head input.vcf"},
  {"query": "Check genotype concordance and output in JSON format", "response": "bcftools gtcheck input1.vcf input2.vcf -O j -o gtcheck_output.json"},
  {"query": "Display the first few records of a VCF file", "response": "bcftools head -n 5 input.vcf"},
  {"query": "Check genotype concordance with a reference panel", "response": "bcftools gtcheck input.vcf -g reference_panel.vcf -o concordance_panel_output.txt"},
  {"query": "Display the header and first few records of a VCF file", "response": "bcftools head -n 10 input.vcf"},
  {"query": "Check genotype concordance and filter based on a threshold", "response": "bcftools gtcheck input.vcf -g reference.vcf | bcftools filter -i 'GT_CONCORDANCE>0.9' -o high_concordance.vcf"},
  {"query": "Display the header of a VCF file after filtering", "response": "bcftools filter -i 'QUAL>20' input.vcf | bcftools head"},
  {"query": "Check genotype concordance and calculate statistics", "response": "bcftools gtcheck input.vcf -g reference.vcf | bcftools stats -s - -o stats.txt"},
  {"query": "Display the header of a VCF file and output in text format", "response": "bcftools head input.vcf -O t -o header.txt"},
  {"query": "Check genotype concordance and normalize variants", "response": "bcftools gtcheck input.vcf -g reference.vcf | bcftools norm -m -any -o normalized_gtcheck.vcf"},
  {"query": "Display the header of a compressed VCF file", "response": "bcftools head input.vcf.gz"},
  {"query": "Check genotype concordance and output as uncompressed BCF", "response": "bcftools gtcheck input.vcf -g reference.vcf -O u -o uncompressed_gtcheck.bcf"},
  {"query": "Display the header and filter variants simultaneously", "response": "bcftools filter -i 'QUAL>30' input.vcf | bcftools head -n 5"},
  {"query": "Check genotype concordance and annotate results", "response": "bcftools gtcheck input.vcf -g reference.vcf | bcftools annotate -a annotations.vcf -o annotated_gtcheck.vcf"},
  {"query": "Display the header of a VCF file after merging", "response": "bcftools merge input1.vcf input2.vcf | bcftools head"},
  {"query": "Check genotype concordance and exclude specific samples", "response": "bcftools gtcheck input.vcf -g reference.vcf | bcftools view -s sample1,sample2 -o sample_excluded_gtcheck.vcf"},
  {"query": "Display the header of a VCF file after concatenation", "response": "bcftools concat input1.vcf input2.vcf | bcftools head"},
  {"query": "Check genotype concordance and select variants by type", "response": "bcftools gtcheck input.vcf -g reference.vcf | bcftools view -v snps -o snps_only_gtcheck.vcf"},
  {"query": "Display the header of a VCF file after applying a custom expression", "response": "bcftools view -i 'DP>10' input.vcf | bcftools head"},
  {"query": "Check genotype concordance for a specific region", "response": "bcftools gtcheck input.vcf -g reference.vcf -r chr1:10000-20000 -o region_specific_gtcheck.vcf"},
  {"query": "Display the header of a VCF file after normalization", "response": "bcftools norm -m -any input.vcf | bcftools head"},
  {"query": "Check genotype concordance and filter non-coding variants", "response": "bcftools gtcheck input.vcf -g reference.vcf | bcftools view -i 'TYPE!=non_coding' -o coding_only_gtcheck.vcf"},
  {"query": "Display the header of a VCF file after subsetting samples", "response": "bcftools view -s sample1,sample2 input.vcf | bcftools head"},
  {"query": "Check genotype concordance and output variant annotations", "response": "bcftools gtcheck input.vcf -g reference.vcf | bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\t[%GT]\n' -o variant_annotations.txt"},
  {"query": "Index a VCF file for fast data retrieval", "response": "bcftools index input.vcf"},
  {"query": "Intersect two VCF files to identify common variants", "response": "bcftools isec input1.vcf input2.vcf -p dir_output"},
  {"query": "Index a VCF file and create a CSI index", "response": "bcftools index -c input.vcf"},
  {"query": "Intersect multiple VCF files and output unique variants", "response": "bcftools isec input1.vcf input2.vcf input3.vcf -n -1 -p unique_variants_output"},
  {"query": "Index a BCF file", "response": "bcftools index input.bcf"},
  {"query": "Create intersections of VCF files and exclude specific regions", "response": "bcftools isec input1.vcf input2.vcf -T ^exclude_regions.bed -p excluded_regions_output"},
  {"query": "Index a VCF file and output to a specific directory", "response": "bcftools index -d specific_dir input.vcf"},
  {"query": "Intersect VCF files and keep only variants present in all", "response": "bcftools isec input1.vcf input2.vcf -n=2 -p all_common_output"},
  {"query": "Index a compressed VCF file", "response": "bcftools index input.vcf.gz"},
  {"query": "Intersect VCF files and output as uncompressed VCF", "response": "bcftools isec input1.vcf input2.vcf -O v -p uncompressed_output"},
  {"query": "Index a VCF file and create a TBI index", "response": "bcftools index -t input.vcf"},
  {"query": "Intersect VCF files and apply filters on the output", "response": "bcftools isec input1.vcf input2.vcf -p dir_output | bcftools filter -i 'QUAL>30' -o filtered_intersection.vcf"},
  {"query": "Index multiple VCF files in a batch", "response": "bcftools index --threads 4 input1.vcf input2.vcf input3.vcf"},
  {"query": "Intersect VCF files and exclude variants with low quality", "response": "bcftools isec input1.vcf input2.vcf -p dir_output | bcftools view -i 'QUAL>20' -o high_qual_intersection.vcf"},
  {"query": "Re-index a VCF file", "response": "bcftools index -f input.vcf"},
  {"query": "Intersect VCF files and output in BCF format", "response": "bcftools isec input1.vcf input2.vcf -O b -p bcf_output"},
  {"query": "Index a VCF file and output index file in a specific path", "response": "bcftools index -o custom_path/index.idx input.vcf"},
  {"query": "Create intersections of VCF files and retain header information", "response": "bcftools isec input1.vcf input2.vcf -p dir_output --write-header"},
  {"query": "Index a VCF file for fast access to specific regions", "response": "bcftools index --regions chr1 input.vcf"},
  {"query": "Intersect VCF files and annotate the output", "response": "bcftools isec input1.vcf input2.vcf -p dir_output | bcftools annotate -a annotations.vcf -o annotated_intersection.vcf"},
  {"query": "Index a VCF file and check for errors", "response": "bcftools index --check input.vcf"},
  {"query": "Create intersections of VCF files and calculate statistics", "response": "bcftools isec input1.vcf input2.vcf -p dir_output | bcftools stats -s - -o stats.txt"},
  {"query": "Index a VCF file and specify a custom index filename", "response": "bcftools index -o custom_index.idx input.vcf"},
  {"query": "Intersect VCF files and convert to PLINK format", "response": "bcftools isec input1.vcf input2.vcf -p dir_output | bcftools convert --plink -o plink_output"},
  {"query": "Index a VCF file and then view specific regions", "response": "bcftools index input.vcf && bcftools view -r chr1:10000-20000 input.vcf -o region_specific.vcf"},
  {"query": "Merge multiple VCF files into one", "response": "bcftools merge input1.vcf input2.vcf -o merged.vcf"},
  {"query": "Generate a pileup from BAM files", "response": "bcftools mpileup -f reference.fa input1.bam input2.bam -o mpileup.bcf"},
  {"query": "Merge VCF files with different sample sets", "response": "bcftools merge input1.vcf input2.vcf -m all -O v -o merged_all.vcf"},
  {"query": "Generate a pileup and call variants", "response": "bcftools mpileup -f reference.fa input.bam | bcftools call -mv -o called.vcf"},
  {"query": "Merge VCF files and output in BCF format", "response": "bcftools merge input1.vcf input2.vcf -O b -o merged.bcf"},
  {"query": "Generate a pileup with minimum base quality", "response": "bcftools mpileup -f reference.fa -Q 20 input.bam -o high_qual_mpileup.bcf"},
  {"query": "Merge and normalize variants in VCF files", "response": "bcftools merge input1.vcf input2.vcf | bcftools norm -m -any -o normalized_merged.vcf"},
  {"query": "Generate a pileup and filter low-quality alignments", "response": "bcftools mpileup -f reference.fa --min-BQ 30 input.bam -o filtered_mpileup.bcf"},
  {"query": "Merge VCF files and annotate the output", "response": "bcftools merge input1.vcf input2.vcf | bcftools annotate -a annotations.vcf -o annotated_merged.vcf"},
  {"query": "Generate a pileup with per-sample read depth", "response": "bcftools mpileup -f reference.fa --annotate DP input.bam -o depth_mpileup.bcf"},
  {"query": "Merge VCF files and keep only PASS records", "response": "bcftools merge input1.vcf input2.vcf | bcftools view -f PASS -o pass_only_merged.vcf"},
  {"query": "Generate a pileup and calculate allele frequencies", "response": "bcftools mpileup -f reference.fa input.bam | bcftools call -mv | bcftools +fill-tags -t AF -o af_mpileup.vcf"},
  {"query": "Merge VCF files and exclude specific regions", "response": "bcftools merge input1.vcf input2.vcf -R exclude.bed -O v -o region_excluded_merged.vcf"},
  {"query": "Generate a pileup and output in uncompressed format", "response": "bcftools mpileup -f reference.fa input.bam -O u -o uncompressed_mpileup.bcf"},
  {"query": "Merge VCF files and compress the output", "response": "bcftools merge input1.vcf input2.vcf -O z -o compressed_merged.vcf.gz"},
  {"query": "Generate a pileup and exclude low mapping quality alignments", "response": "bcftools mpileup -f reference.fa --min-MQ 30 input.bam -o mq_filtered_mpileup.bcf"},
  {"query": "Merge VCF files and recalculate AC and AN", "response": "bcftools merge input1.vcf input2.vcf | bcftools +fill-tags -t AC,AN -o recalculated_merged.vcf"},
  {"query": "Generate a pileup for a specific region", "response": "bcftools mpileup -f reference.fa -r chr1:10000-20000 input.bam -o region_mpileup.bcf"},
  {"query": "Merge VCF files and index the output", "response": "bcftools merge input1.vcf input2.vcf -O v -o merged.vcf && bcftools index merged.vcf"},
  {"query": "Generate a pileup and exclude specific regions", "response": "bcftools mpileup -f reference.fa -R exclude.bed input.bam -o region_excluded_mpileup.bcf"},
  {"query": "Merge VCF files and create a consensus sequence", "response": "bcftools merge input1.vcf input2.vcf | bcftools consensus -f reference.fa -o consensus_merged.fa"},
  {"query": "Generate a pileup and select specific types of variants", "response": "bcftools mpileup -f reference.fa input.bam | bcftools call -mv | bcftools view -v snps -o snps_mpileup.vcf"},
  {"query": "Merge VCF files and output in tab-delimited format", "response": "bcftools merge input1.vcf input2.vcf | bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\n' -o merged.tsv"},
  {"query": "Generate a pileup and apply complex filtering expressions", "response": "bcftools mpileup -f reference.fa input.bam | bcftools filter -e 'DP<10 && QUAL<20' -o filtered_mpileup.vcf"},
  {"query": "Merge VCF files and subset to specific samples", "response": "bcftools merge input1.vcf input2.vcf | bcftools view -s sample1,sample2 -o sample_subset_merged.vcf"},
  {"query": "Normalize indels in a VCF file", "response": "bcftools norm -f reference.fa input.vcf -o normalized.vcf"},
  {"query": "Split multi-allelic sites into separate records", "response": "bcftools norm -m -any input.vcf -o split.vcf"},
  {"query": "Normalize indels and remove duplicate alleles", "response": "bcftools norm -f reference.fa -D input.vcf -o norm_dedup.vcf"},
  {"query": "Check VCF file for normalization issues", "response": "bcftools norm -c s -f reference.fa input.vcf"},
  {"query": "Normalize indels and fill missing genotypes", "response": "bcftools norm -f reference.fa --set-GTs . input.vcf -o filled.vcf"},
  {"query": "Normalize indels and left-align variants", "response": "bcftools norm -f reference.fa --left-align input.vcf -o left_aligned.vcf"},
  {"query": "Split multi-allelic records and output in BCF format", "response": "bcftools norm -m -any -O b input.vcf -o split.bcf"},
  {"query": "Normalize indels and drop info not matching REF/ALT", "response": "bcftools norm -f reference.fa --drop-mismatching-alts input.vcf -o clean_info.vcf"},
  {"query": "Normalize indels and recalculate AC, AN tags", "response": "bcftools norm -f reference.fa --fasta-ref reference.fa --calc-ac input.vcf -o recalculated_ac_an.vcf"},
  {"query": "Normalize indels and exclude specific regions", "response": "bcftools norm -f reference.fa -R exclude.bed input.vcf -o region_excluded.vcf"},
  {"query": "Normalize indels and output in uncompressed BCF format", "response": "bcftools norm -f reference.fa -O u input.vcf -o uncompressed.bcf"},
  {"query": "Split multi-allelic sites and filter for biallelic SNPs", "response": "bcftools norm -m -any input.vcf | bcftools view -m2 -M2 -v snps -o biallelic_snps.vcf"},
  {"query": "Normalize indels and annotate with gene names", "response": "bcftools norm -f reference.fa input.vcf | bcftools annotate -a genes.gff -o annotated.vcf"},
  {"query": "Normalize indels and convert to tab-delimited format", "response": "bcftools norm -f reference.fa input.vcf | bcftools query -H -o normalized.tsv"},
  {"query": "Normalize indels and keep only variants in a region", "response": "bcftools norm -f reference.fa -r chr1:10000-20000 input.vcf -o region_specific.vcf"},
  {"query": "Normalize indels and merge with another VCF file", "response": "bcftools norm -f reference.fa input.vcf | bcftools merge input2.vcf -o merged.vcf"},
  {"query": "Normalize indels and calculate statistics", "response": "bcftools norm -f reference.fa input.vcf | bcftools stats -s - -o stats.txt"},
  {"query": "Normalize indels and output variant annotations", "response": "bcftools norm -f reference.fa input.vcf | bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\t[%INFO]\n' -o variant_annotations.txt"},
  {"query": "Normalize indels and subset to specific samples", "response": "bcftools norm -f reference.fa input.vcf | bcftools view -s sample1,sample2 -o sample_subset.vcf"},
  {"query": "Normalize indels and exclude non-PASS variants", "response": "bcftools norm -f reference.fa input.vcf | bcftools view -f PASS -o pass_only.vcf"},
  {"query": "Normalize indels and convert to JSON format", "response": "bcftools norm -f reference.fa input.vcf | bcftools view -O j -o output.json"},
  {"query": "Normalize indels and output as compressed VCF", "response": "bcftools norm -f reference.fa input.vcf -O z -o compressed.vcf.gz"},
  {"query": "Normalize indels and split by chromosome", "response": "bcftools norm -f reference.fa input.vcf | bcftools +split -o split_by_chrom"},
  {"query": "Normalize indels and filter low-quality variants", "response": "bcftools norm -f reference.fa input.vcf | bcftools filter -e 'QUAL<20' -o high_qual.vcf"},
  {"query": "Normalize indels and output header only", "response": "bcftools norm -f reference.fa input.vcf | bcftools view -h -o header_only.txt"},
  {"query": "Detect whole-chromosome aberrations in a VCF file", "response": "bcftools polysomy input.vcf -o aberrations_output.txt"},
  {"query": "Detect contaminations in a VCF file", "response": "bcftools polysomy input.vcf --detect-contamination -o contamination_output.txt"},
  {"query": "Transform VCF into a custom tab-delimited format", "response": "bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\n' input.vcf -o output.txt"},
  {"query": "Extract sample names from a VCF file", "response": "bcftools query -l input.vcf -o sample_names.txt"},
  {"query": "Output genotype information for each sample in a VCF file", "response": "bcftools query -f '%CHROM\t%POS\t[%GT]\n' input.vcf -o genotypes.txt"},
  {"query": "Transform VCF into a format with allele frequencies", "response": "bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\t[%AF]\n' input.vcf -o allele_frequencies.txt"},
  {"query": "Extract specific INFO fields from a VCF file", "response": "bcftools query -f '%CHROM\t%POS\t%INFO/DP\t%INFO/AF\n' input.vcf -o info_fields.txt"},
  {"query": "Modify the header of a VCF file", "response": "bcftools reheader -h new_header.txt input.vcf -o reheadered.vcf"},
  {"query": "Change sample names in a VCF file", "response": "bcftools reheader -s sample_names.txt input.vcf -o renamed_samples.vcf"},
  {"query": "Identify runs of homozygosity in a VCF file", "response": "bcftools roh input.vcf -o roh_output.txt"},
  {"query": "Identify autozygosity in a VCF file", "response": "bcftools roh --autozyg input.vcf -o autozyg_output.txt"},
  {"query": "Sort a VCF file", "response": "bcftools sort input.vcf -o sorted.vcf"},
  {"query": "Sort a BCF file", "response": "bcftools sort input.bcf -O b -o sorted.bcf"},
  {"query": "Produce VCF stats", "response": "bcftools stats input.vcf -o vcf_stats.txt"},
  {"query": "Produce BCF stats", "response": "bcftools stats input.bcf -o bcf_stats.txt"},
  {"query": "Detect CNVs and annotate with gene names", "response": "bcftools polysomy input.vcf | bcftools annotate -a genes.gff -o cnv_genes.vcf"},
  {"query": "Query VCF for specific genotype patterns", "response": "bcftools query -i 'GT=\"het\"' -f '%CHROM\t%POS\t%REF\t%ALT\n' input.vcf -o het_variants.txt"},
  {"query": "Reheader VCF and immediately view the header", "response": "bcftools reheader -s new_samples.txt input.vcf | bcftools view -h"},
  {"query": "Identify ROH and output in tab-delimited format", "response": "bcftools roh input.vcf | bcftools query -f '%CHROM\t%POS\t%END\t%ROH\n' -o roh_regions.txt"},
  {"query": "Sort VCF and calculate stats post-sorting", "response": "bcftools sort input.vcf | bcftools stats -o sorted_stats.txt"},
  {"query": "Detect aberrations and filter based on quality", "response": "bcftools polysomy input.vcf | bcftools filter -i 'QUAL>20' -o high_qual_aberrations.vcf"},
  {"query": "Query VCF and transform to JSON format", "response": "bcftools query -f '%CHROM\t%POS\t%REF\t%ALT\n' input.vcf | bcftools view -O j -o output.json"},
  {"query": "Reheader VCF and merge with another VCF", "response": "bcftools reheader -s new_samples.txt input.vcf | bcftools merge another.vcf -o merged.vcf"},
  {"query": "Identify ROH and merge with genotype data", "response": "bcftools roh input.vcf | bcftools merge genotypes.vcf -o roh_genotypes.vcf"},
  {"query": "Sort VCF and then extract specific regions", "response": "bcftools sort input.vcf | bcftools view -r chr1:10000-20000 -o region_sorted.vcf"},
  {"query": "Generate stats for a VCF and then normalize", "response": "bcftools stats input.vcf | bcftools norm -f reference.fa -o normalized.vcf"},
  {"query": "Detect CNVs and then sort the output", "response": "bcftools polysomy input.vcf | bcftools sort -o sorted_cnv.vcf"},
  {"query": "Query VCF for indels and then annotate", "response": "bcftools query -i 'TYPE=\"indel\"' -f '%CHROM\t%POS\t%REF\t%ALT\n' input.vcf | bcftools annotate -a annotations.vcf -o indels_annotated.vcf"},
  {"query": "Reheader VCF and then index for fast access", "response": "bcftools reheader -s new_samples.txt input.vcf | bcftools index -o indexed.vcf"},
  {"query": "Identify ROH and then filter based on length", "response": "bcftools roh input.vcf | bcftools view -i 'LEN>10000' -o long_roh.vcf"},
  {"query": "Sort VCF and then convert to PLINK format", "response": "bcftools sort input.vcf | bcftools convert --plink -o plink_output"},
  {"query": "Generate stats for a VCF and then reheader", "response": "bcftools stats input.vcf | bcftools reheader -s new_header.txt -o reheadered_stats.vcf"},
  {"query": "Detect CNVs and then compress the VCF", "response": "bcftools polysomy input.vcf | bcftools view -O z -o compressed_cnv.vcf.gz"},
  {"query": "Query VCF for specific alleles and then normalize", "response": "bcftools query -i 'ALT=\"A\"' -f '%CHROM\t%POS\t%REF\t%ALT\n' input.vcf | bcftools norm -f reference.fa -o a_allele_norm.vcf"},
  {"query": "Reheader VCF and then apply complex filtering", "response": "bcftools reheader -s new_samples.txt input.vcf | bcftools filter -e 'QUAL<20' -o high_qual_reheadered.vcf"},
  {"query": "Identify ROH and then output as compressed BCF", "response": "bcftools roh input.vcf | bcftools view -O b -o compressed_roh.bcf"}
]

